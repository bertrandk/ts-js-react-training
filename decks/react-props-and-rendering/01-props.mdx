import { FullScreenCode, Invert } from "mdx-deck/layouts";
import { Head, Appear, Image, withDeck } from "mdx-deck";
import { CodeSurfer } from "mdx-deck-code-surfer";
import nightOwl from "prism-react-renderer/themes/nightOwl";
import ReplIt from "../../components/ReplIt";
import CodeSandbox from "../../components/CodeSandbox";
import Box from "../../components/Box";
const BRANCH_NAME = "master"; // todo: change before merge

export default Invert;

# React - Props

---

- How do we get data into components?
- How do we let components communicate?
- How do we make components reusable?

---

# Props

---

# Props

- Define the API of the component
- The data it expects so it can render
- Can also pass down callbacks to help components communicate
- Props become the attributes on your component that you use to pass in data

---

export default FullScreenCode;

## Example: Passing Prop Data

<CodeSandbox src="https://codesandbox.io/embed/3kv214881q?fontsize=14&hidenavigation=1" />

```notes
Changed example to not use a loop yet, as we haven't covered
rendering lists yet, or conditional rendering
```

---

<CodeSurfer
  code={require("!!raw-loader!./snippets/props.snippet")}
  theme={nightOwl}
  lang="jsx"
  title="Props Recap"
  showNumbers
  steps={[
    {},
    {lines: [1], notes: "Each function is called with a single property: `props`"},
    {lines: [4], notes: "Attributes become keys on the prop object"},
     {
      tokens: {
        1: [5,15,16,17],
        4: [5,6]
      },
      notes: "name attribute becomes props.name"
    },{}
  ]}
/>
---

## Destructuring Props

- Props is an object that your component will always receive
- The object keys are the attributes you specify on the component
- You can destructure props in the component method

---

<CodeSurfer
  code={require("raw-loader!./snippets/destructuring.snippet")}
  theme={nightOwl}
  lang="jsx"
  title="Props Recap - Destructuring"
  showNumbers
  steps={[
    {},
    {
      lines: [1],
      notes: "Each function is called with a single property: `props`"
    },
    { lines: [2], notes: "Need to access via prop.value" },
    { lines: [4], notes: "Or make use of Destructuring" },
    { lines: [5], notes: "And able to just use greeting and name" }
  ]}
/>

---

## Props

- A prop can be anything, including a function
- You can pass raw values or variables
- This makes your component dynamic

---

## Static Checking with PropTypes

- The React prop-types package allows you to check props being passed into a component
- Not like typescript; If an invalid prop type is passed, your app will still render
- You will instead receive warnings in the console

---

export default FullScreenCode;

```javascript
import PropTypes from 'prop-types';

Card.propTypes = {
    id: PropTypes.number.isRequired,
    name: PropTypes.shape({
      firstName: string,
      lastName: string
    })
    email: PropTypes.string.isRequired
};
```

---

## Default Values

- The prop-types package also lets you specify defaults
- Specifying defaults can help you avoid null checking
- undefined values WILL overwrite default values

```javascript
ManyGreetings.defaultProps = {
  names: []
};
```

---

### Exercise: Adding Props

- Create a component that takes two props - num1, num2
- The component should display the equation of "num1 + num2"
- The component should also display the result
- Use `prop-types` package to ensure the props are numbers
- Use `prop-types` to set the default value to 0

---

export default FullScreenCode;

### Props - Start

<CodeSandbox src="https://codesandbox.io/embed/9lnz3x7o1p?autoresize=1&fontsize=14&hidenavigation=1" />

---

export default FullScreenCode;

### Props - Solution

<CodeSandbox src="https://codesandbox.io/embed/4qz761yz49?fontsize=14" />

---

# Break / Q&A
